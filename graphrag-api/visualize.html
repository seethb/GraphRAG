<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knowledge Graph Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.6/dist/vis-network.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container { max-width: 1800px; margin: 0 auto; }

        header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        header p { opacity: 0.9; }

        .main-panel {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        /* Controls Bar */
        .controls-bar {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ed 100%);
            padding: 15px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            border-bottom: 1px solid #ddd;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }

        .control-group label {
            font-size: 12px;
            font-weight: 600;
            color: #555;
            white-space: nowrap;
        }

        /* Search Box */
        .search-box {
            flex: 1;
            min-width: 250px;
            max-width: 400px;
        }

        .search-box input {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .search-box input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        /* Buttons */
        button {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        button:active { transform: translateY(0); }

        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-success { background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%); color: white; }
        .btn-info { background: linear-gradient(135deg, #56CCF2 0%, #2F80ED 100%); color: white; }
        .btn-warning { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; }
        .btn-secondary { background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%); color: white; }
        .btn-dark { background: linear-gradient(135deg, #434343 0%, #000000 100%); color: white; }

        select {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 13px;
            background: white;
            cursor: pointer;
            min-width: 140px;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
        }

        /* Main Content Layout */
        .content-wrapper {
            display: flex;
            height: 700px;
        }

        /* Graph Container */
        #graph {
            flex: 1;
            background: radial-gradient(circle at center, #ffffff 0%, #f0f2f5 100%);
        }

        /* Side Panel */
        .side-panel {
            width: 320px;
            background: #f8f9fa;
            border-left: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-section {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        .panel-section h3 {
            font-size: 14px;
            font-weight: 700;
            color: #333;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Legend */
        .legend-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: white;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .legend-item:hover { background: #e8e8e8; }
        .legend-item.inactive { opacity: 0.4; }
        .legend-item.active { border-color: #667eea; }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .legend-label {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .legend-count {
            font-weight: 600;
            color: #888;
            font-size: 11px;
        }

        /* Node Details */
        .node-details {
            flex: 1;
            overflow-y: auto;
        }

        .detail-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .detail-card h4 {
            font-size: 16px;
            color: #333;
            margin-bottom: 10px;
            word-break: break-word;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
            font-size: 13px;
        }

        .detail-row:last-child { border-bottom: none; }
        .detail-label { color: #888; }
        .detail-value { color: #333; font-weight: 500; text-align: right; max-width: 60%; word-break: break-word; }

        .no-selection {
            text-align: center;
            color: #999;
            padding: 30px;
            font-size: 13px;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            padding: 15px 20px;
            gap: 30px;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }

        .stat-icon {
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .stat-info .stat-value {
            font-size: 22px;
            font-weight: 700;
        }

        .stat-info .stat-label {
            font-size: 11px;
            opacity: 0.8;
            text-transform: uppercase;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 340px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: white;
            border: 1px solid #ddd;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        /* Graph Container Wrapper */
        .graph-wrapper {
            position: relative;
            flex: 1;
            display: flex;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .loading-overlay.hidden { display: none; }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 15px;
            color: #666;
            font-weight: 500;
        }

        /* Search Results */
        .search-results {
            position: absolute;
            top: 60px;
            left: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            max-height: 300px;
            overflow-y: auto;
            z-index: 150;
            min-width: 300px;
            display: none;
        }

        .search-results.active { display: block; }

        .search-result-item {
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .search-result-item:hover { background: #f5f5f5; }
        .search-result-item:last-child { border-bottom: none; }

        .result-name { font-weight: 600; color: #333; }
        .result-type { font-size: 12px; color: #888; margin-top: 3px; }

        /* Responsive */
        @media (max-width: 1200px) {
            .side-panel { width: 280px; }
            .zoom-controls { right: 300px; }
        }

        @media (max-width: 900px) {
            .content-wrapper { flex-direction: column; height: auto; }
            .side-panel { width: 100%; height: 300px; }
            #graph { height: 500px; }
            .zoom-controls { right: 20px; bottom: 320px; }
        }

        /* Tooltip */
        .custom-tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸ”® Knowledge Graph Explorer</h1>
            <p>Visualize and Navigate Your Knowledge Network</p>
        </header>

        <div class="main-panel">
            <!-- Controls Bar -->
            <div class="controls-bar">
                <div class="control-group search-box">
                    <input type="text" id="searchInput" placeholder="ðŸ” Search nodes..." onkeyup="handleSearch(event)">
                </div>

                <div class="control-group">
                    <label>Layout:</label>
                    <select id="layoutSelect" onchange="changeLayout()">
                        <option value="physics">Force Directed</option>
                        <option value="hierarchicalUD">Hierarchical â†“</option>
                        <option value="hierarchicalLR">Hierarchical â†’</option>
                        <option value="circular">Circular</option>
                        <option value="random">Random</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Node Size:</label>
                    <select id="nodeSizeSelect" onchange="changeNodeSize()">
                        <option value="fixed">Fixed</option>
                        <option value="connections">By Connections</option>
                    </select>
                </div>

                <button class="btn-primary" onclick="loadGraph()">
                    ðŸ”„ Refresh
                </button>
                <button class="btn-success" onclick="resetView()">
                    ðŸŽ¯ Center
                </button>
                <button class="btn-info" onclick="togglePhysics()">
                    âš¡ Physics
                </button>
                <button class="btn-warning" onclick="expandSelected()">
                    ðŸ”— Expand
                </button>
                <button class="btn-dark" onclick="exportGraph()">
                    ðŸ“¥ Export
                </button>
            </div>

            <!-- Main Content -->
            <div class="content-wrapper">
                <div class="graph-wrapper">
                    <div id="graph"></div>
                    
                    <!-- Loading Overlay -->
                    <div class="loading-overlay" id="loadingOverlay">
                        <div class="spinner"></div>
                        <div class="loading-text">Loading Graph...</div>
                    </div>

                    <!-- Search Results -->
                    <div class="search-results" id="searchResults"></div>

                    <!-- Zoom Controls -->
                    <div class="zoom-controls">
                        <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
                        <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">âˆ’</button>
                        <button class="zoom-btn" onclick="resetView()" title="Fit All">âŠ™</button>
                    </div>
                </div>

                <!-- Side Panel -->
                <div class="side-panel">
                    <!-- Legend -->
                    <div class="panel-section">
                        <h3>ðŸ“Š Node Types</h3>
                        <div class="legend-grid" id="legendContainer">
                            <!-- Populated dynamically -->
                        </div>
                    </div>

                    <!-- Node Details -->
                    <div class="panel-section node-details" id="nodeDetails">
                        <h3>ðŸ“‹ Details</h3>
                        <div class="no-selection">
                            Click a node to view details
                        </div>
                    </div>

                    <!-- Connections -->
                    <div class="panel-section" id="connectionsPanel" style="display:none;">
                        <h3>ðŸ”— Connections</h3>
                        <div id="connectionsList"></div>
                    </div>
                </div>
            </div>

            <!-- Stats Bar -->
            <div class="stats-bar">
                <div class="stat-item">
                    <div class="stat-icon">ðŸ”µ</div>
                    <div class="stat-info">
                        <div class="stat-value" id="nodeCount">0</div>
                        <div class="stat-label">Nodes</div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon">ðŸ”—</div>
                    <div class="stat-info">
                        <div class="stat-value" id="edgeCount">0</div>
                        <div class="stat-label">Edges</div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon">ðŸ“‚</div>
                    <div class="stat-info">
                        <div class="stat-value" id="typeCount">0</div>
                        <div class="stat-label">Types</div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon">ðŸŽ¯</div>
                    <div class="stat-info">
                        <div class="stat-value" id="selectedCount">0</div>
                        <div class="stat-label">Selected</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let network = null;
        let nodesDataset = null;
        let edgesDataset = null;
        let allNodes = [];
        let allEdges = [];
        let physicsEnabled = true;
        let activeFilters = new Set();
        let nodeTypeCounts = {};

        const API_URL = 'http://10.33.16.10:5005';

        const typeColors = {
            'Database': '#4CAF50',
            'Framework': '#2196F3',
            'Language': '#FF9800',
            'Technology': '#9C27B0',
            'Organization': '#F44336',
            'Platform': '#00BCD4',
            'Product': '#E91E63',
            'Protocol': '#FF5722',
            'Environment': '#009688',
            'Concept': '#795548',
            'Person': '#3F51B5',
            'Service': '#CDDC39',
            'Tool': '#FFC107',
            'Library': '#8BC34A',
            'API': '#03A9F4',
            'Standard': '#9E9E9E',
            'Company': '#FF5722',
            'Feature': '#673AB7'
        };

        function getColorByType(type) {
            return typeColors[type] || '#607D8B';
        }

        function showLoading(show) {
            document.getElementById('loadingOverlay').classList.toggle('hidden', !show);
        }

        async function loadGraph() {
            showLoading(true);
            try {
                const response = await fetch(`${API_URL}/graph/visualize`);
                const data = await response.json();

                // Count node types
                nodeTypeCounts = {};
                data.nodes.forEach(node => {
                    nodeTypeCounts[node.type] = (nodeTypeCounts[node.type] || 0) + 1;
                });

                // Prepare nodes
                allNodes = data.nodes.map(node => ({
                    id: node.id,
                    label: node.label,
                    title: createTooltip(node),
                    color: {
                        background: getColorByType(node.type),
                        border: shadeColor(getColorByType(node.type), -20),
                        highlight: { background: shadeColor(getColorByType(node.type), 20), border: '#333' },
                        hover: { background: shadeColor(getColorByType(node.type), 10), border: '#333' }
                    },
                    shape: 'dot',
                    size: 25,
                    font: { size: 14, color: '#333' },
                    type: node.type,
                    properties: node.properties || {}
                }));

                // Prepare edges
                allEdges = data.edges.map((edge, idx) => ({
                    id: idx,
                    from: edge.source,
                    to: edge.target,
                    label: edge.label,
                    arrows: { to: { enabled: true, scaleFactor: 0.8 } },
                    width: Math.max(1, (edge.weight || 1) * 1.5),
                    color: { color: '#999', highlight: '#667eea', hover: '#667eea' },
                    font: { size: 11, color: '#666', strokeWidth: 3, strokeColor: '#fff' },
                    smooth: { type: 'continuous' }
                }));

                nodesDataset = new vis.DataSet(allNodes);
                edgesDataset = new vis.DataSet(allEdges);

                const container = document.getElementById('graph');
                const options = getNetworkOptions();

                network = new vis.Network(container, { nodes: nodesDataset, edges: edgesDataset }, options);

                // Event listeners
                network.on('click', handleNodeClick);
                network.on('doubleClick', handleDoubleClick);
                network.on('hoverNode', () => document.body.style.cursor = 'pointer');
                network.on('blurNode', () => document.body.style.cursor = 'default');

                // Update UI
                updateStats(data.stats);
                updateLegend();

            } catch (error) {
                console.error('Error loading graph:', error);
                alert('Error loading graph: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        function getNetworkOptions() {
            return {
                physics: {
                    enabled: physicsEnabled,
                    barnesHut: {
                        gravitationalConstant: -3000,
                        centralGravity: 0.3,
                        springLength: 150,
                        springConstant: 0.04,
                        damping: 0.09
                    },
                    stabilization: { iterations: 150 }
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 200,
                    hideEdgesOnDrag: true,
                    multiselect: true
                },
                nodes: {
                    borderWidth: 2,
                    shadow: { enabled: true, size: 10, x: 3, y: 3 }
                },
                edges: {
                    shadow: false,
                    smooth: { enabled: true, type: 'continuous', roundness: 0.5 }
                }
            };
        }

        function createTooltip(node) {
            let html = `<strong>${node.label}</strong><br>Type: ${node.type}`;
            if (node.properties) {
                for (const [key, value] of Object.entries(node.properties)) {
                    if (value && key !== 'name' && key !== 'type') {
                        html += `<br>${key}: ${String(value).substring(0, 100)}`;
                    }
                }
            }
            return html;
        }

        function handleNodeClick(params) {
            if (params.nodes.length > 0) {
                const nodeId = params.nodes[0];
                const node = nodesDataset.get(nodeId);
                showNodeDetails(node);
                showConnections(nodeId);
                document.getElementById('selectedCount').textContent = params.nodes.length;
            } else {
                clearNodeDetails();
                document.getElementById('selectedCount').textContent = '0';
            }
        }

        function handleDoubleClick(params) {
            if (params.nodes.length > 0) {
                network.focus(params.nodes[0], {
                    scale: 1.5,
                    animation: { duration: 500, easingFunction: 'easeInOutQuad' }
                });
            }
        }

        function showNodeDetails(node) {
            const container = document.getElementById('nodeDetails');
            let html = `<h3>ðŸ“‹ Details</h3><div class="detail-card">`;
            html += `<h4>${node.label}</h4>`;
            html += `<div class="detail-row"><span class="detail-label">Type</span><span class="detail-value" style="color:${node.color.background}">${node.type}</span></div>`;
            html += `<div class="detail-row"><span class="detail-label">ID</span><span class="detail-value">${node.id}</span></div>`;
            
            if (node.properties) {
                for (const [key, value] of Object.entries(node.properties)) {
                    if (value && key !== 'name' && key !== 'type') {
                        html += `<div class="detail-row"><span class="detail-label">${key}</span><span class="detail-value">${String(value).substring(0, 150)}</span></div>`;
                    }
                }
            }
            html += `</div>`;
            container.innerHTML = html;
        }

        function showConnections(nodeId) {
            const connections = network.getConnectedNodes(nodeId);
            const panel = document.getElementById('connectionsPanel');
            const list = document.getElementById('connectionsList');
            
            if (connections.length > 0) {
                panel.style.display = 'block';
                let html = '';
                connections.forEach(connId => {
                    const connNode = nodesDataset.get(connId);
                    if (connNode) {
                        html += `<div class="legend-item" onclick="focusNode('${connId}')">
                            <span class="legend-color" style="background:${connNode.color.background}"></span>
                            <span class="legend-label">${connNode.label}</span>
                        </div>`;
                    }
                });
                list.innerHTML = html;
            } else {
                panel.style.display = 'none';
            }
        }

        function clearNodeDetails() {
            document.getElementById('nodeDetails').innerHTML = `<h3>ðŸ“‹ Details</h3><div class="no-selection">Click a node to view details</div>`;
            document.getElementById('connectionsPanel').style.display = 'none';
        }

        function updateStats(stats) {
            document.getElementById('nodeCount').textContent = stats.node_count || allNodes.length;
            document.getElementById('edgeCount').textContent = stats.edge_count || allEdges.length;
            document.getElementById('typeCount').textContent = Object.keys(nodeTypeCounts).length;
        }

        function updateLegend() {
            const container = document.getElementById('legendContainer');
            let html = '';
            
            const sortedTypes = Object.entries(nodeTypeCounts).sort((a, b) => b[1] - a[1]);
            
            sortedTypes.forEach(([type, count]) => {
                const isActive = activeFilters.size === 0 || activeFilters.has(type);
                html += `<div class="legend-item ${isActive ? '' : 'inactive'}" onclick="toggleFilter('${type}')">
                    <span class="legend-color" style="background:${getColorByType(type)}"></span>
                    <span class="legend-label">${type}</span>
                    <span class="legend-count">${count}</span>
                </div>`;
            });
            
            container.innerHTML = html;
        }

        function toggleFilter(type) {
            if (activeFilters.has(type)) {
                activeFilters.delete(type);
            } else {
                if (activeFilters.size === 0) {
                    // First filter - hide all others
                    Object.keys(nodeTypeCounts).forEach(t => {
                        if (t !== type) activeFilters.add(t);
                    });
                    activeFilters.delete(type);
                    activeFilters = new Set([type]);
                } else {
                    activeFilters.add(type);
                }
            }

            if (activeFilters.size === Object.keys(nodeTypeCounts).length) {
                activeFilters.clear();
            }

            applyFilters();
            updateLegend();
        }

        function applyFilters() {
            allNodes.forEach(node => {
                const visible = activeFilters.size === 0 || activeFilters.has(node.type);
                nodesDataset.update({ id: node.id, hidden: !visible });
            });
        }

        function handleSearch(event) {
            const query = event.target.value.toLowerCase().trim();
            const resultsContainer = document.getElementById('searchResults');

            if (query.length < 2) {
                resultsContainer.classList.remove('active');
                return;
            }

            const matches = allNodes.filter(node => 
                node.label.toLowerCase().includes(query) || 
                node.type.toLowerCase().includes(query)
            ).slice(0, 10);

            if (matches.length > 0) {
                resultsContainer.innerHTML = matches.map(node => `
                    <div class="search-result-item" onclick="focusNode('${node.id}')">
                        <div class="result-name">${highlightMatch(node.label, query)}</div>
                        <div class="result-type">${node.type}</div>
                    </div>
                `).join('');
                resultsContainer.classList.add('active');
            } else {
                resultsContainer.innerHTML = '<div class="search-result-item"><div class="result-name">No results found</div></div>';
                resultsContainer.classList.add('active');
            }

            if (event.key === 'Enter' && matches.length > 0) {
                focusNode(matches[0].id);
                resultsContainer.classList.remove('active');
            }

            if (event.key === 'Escape') {
                resultsContainer.classList.remove('active');
            }
        }

        function highlightMatch(text, query) {
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<strong style="color:#667eea">$1</strong>');
        }

        function focusNode(nodeId) {
            document.getElementById('searchResults').classList.remove('active');
            document.getElementById('searchInput').value = '';
            
            network.selectNodes([nodeId]);
            network.focus(nodeId, {
                scale: 1.2,
                animation: { duration: 500, easingFunction: 'easeInOutQuad' }
            });
            
            const node = nodesDataset.get(nodeId);
            showNodeDetails(node);
            showConnections(nodeId);
            document.getElementById('selectedCount').textContent = '1';
        }

        function changeLayout() {
            const layout = document.getElementById('layoutSelect').value;
            let options = { physics: { enabled: physicsEnabled } };

            switch (layout) {
                case 'hierarchicalUD':
                    options.layout = { hierarchical: { direction: 'UD', sortMethod: 'hubsize', nodeSpacing: 150 } };
                    options.physics = { enabled: false };
                    break;
                case 'hierarchicalLR':
                    options.layout = { hierarchical: { direction: 'LR', sortMethod: 'hubsize', nodeSpacing: 150 } };
                    options.physics = { enabled: false };
                    break;
                case 'circular':
                    arrangeCircular();
                    return;
                case 'random':
                    options.layout = { randomSeed: Math.random() * 1000 };
                    break;
                default:
                    options.layout = { hierarchical: false };
                    options.physics = { enabled: true, barnesHut: { gravitationalConstant: -3000 } };
            }

            network.setOptions(options);
        }

        function arrangeCircular() {
            const nodes = nodesDataset.get();
            const centerX = 0;
            const centerY = 0;
            const radius = Math.max(300, nodes.length * 15);

            nodes.forEach((node, index) => {
                const angle = (2 * Math.PI * index) / nodes.length;
                nodesDataset.update({
                    id: node.id,
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                });
            });

            network.setOptions({ physics: { enabled: false } });
            setTimeout(() => network.fit(), 100);
        }

        function changeNodeSize() {
            const sizeMode = document.getElementById('nodeSizeSelect').value;
            
            allNodes.forEach(node => {
                let size = 25;
                if (sizeMode === 'connections') {
                    const connections = network.getConnectedNodes(node.id).length;
                    size = Math.max(15, Math.min(50, 15 + connections * 5));
                }
                nodesDataset.update({ id: node.id, size: size });
            });
        }

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            network.setOptions({ physics: { enabled: physicsEnabled } });
        }

        function expandSelected() {
            const selected = network.getSelectedNodes();
            if (selected.length === 0) {
                alert('Please select a node first');
                return;
            }

            const connectedNodes = new Set(selected);
            selected.forEach(nodeId => {
                network.getConnectedNodes(nodeId).forEach(id => connectedNodes.add(id));
            });

            network.selectNodes([...connectedNodes]);
            network.fit({ nodes: [...connectedNodes], animation: true });
            document.getElementById('selectedCount').textContent = connectedNodes.size;
        }

        function resetView() {
            if (network) {
                network.fit({ animation: { duration: 500, easingFunction: 'easeInOutQuad' } });
            }
        }

        function zoomIn() {
            const scale = network.getScale() * 1.3;
            network.moveTo({ scale: scale, animation: { duration: 300 } });
        }

        function zoomOut() {
            const scale = network.getScale() / 1.3;
            network.moveTo({ scale: scale, animation: { duration: 300 } });
        }

        function exportGraph() {
            const exportData = {
                nodes: allNodes.map(n => ({ id: n.id, label: n.label, type: n.type })),
                edges: allEdges.map(e => ({ from: e.from, to: e.to, label: e.label })),
                exported: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'knowledge-graph-export.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + 
                (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + 
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + 
                (B < 255 ? B < 1 ? 0 : B : 255)
            ).toString(16).slice(1);
        }

        // Close search results when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-box') && !e.target.closest('.search-results')) {
                document.getElementById('searchResults').classList.remove('active');
            }
        });

        // Initialize
        window.onload = loadGraph;
    </script>
</body>
</html>

